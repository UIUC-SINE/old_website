<!DOCTYPE html>
<html lang=en>

<head>
  <title>Image Registration Survey and Simulations</title>
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" type="text/css" href="/styles.css" /> 
  <link rel="stylesheet" type="text/css" href="/codehilite.css" /> 
<script type="text/javascript"
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>
<body>
<main>
  <article>
    <header>
      <h1>Image Registration Survey and Simulations</h1>
      <time datetime="2019-05-27">2019-05-27</time> - Evan Widloski
    </header>
    <div class="toc">
<ul>
<li><a href="#interesting-papers">Interesting papers</a></li>
<li><a href="#forward-model-and-error-metrics">Forward Model and Error Metrics</a></li>
<li><a href="#correlation-registration-methods">Correlation Registration Methods</a><ul>
<li><a href="#direct-correlation">Direct Correlation</a></li>
<li><a href="#fft-correlation">FFT Correlation</a></li>
<li><a href="#sequential-similarity-detection-algorithm-ssda">Sequential Similarity Detection Algorithm (SSDA)</a></li>
<li><a href="#phase-correlation">Phase Correlation</a></li>
</ul>
</li>
<li><a href="#handling-scale-and-rotation">Handling Scale and Rotation</a><ul>
<li><a href="#log-polar-fourier-mellin-transform">Log-Polar (Fourier-Mellin) transform</a></li>
</ul>
</li>
<li><a href="#other-methods-not-investigated">Other methods not investigated</a></li>
<li><a href="#other-papers">Other Papers</a></li>
<li><a href="#research-ideas">Research Ideas</a></li>
</ul>
</div>
<p>The goal of this report is to introduce a mathematical model of the image registration problem and to explore some popular classical and contemporary algorithms for solving this problem.</p>
<p>Particular focus is given to the log-polar + phase correlation method, which has had popularity in recent years and is theoretically straightforward.</p>
<h3 id="interesting-papers">Interesting papers</h3>
<ul>
<li><a href="https://dl.acm.org/citation.cfm?id=146374">L. G. Brown</a> - 1992<ul>
<li>survey of more classical methods</li>
<li>widely cited in many of the papers I read</li>
</ul>
</li>
<li><a href="https://preetikale.files.wordpress.com/2018/07/handbook-of-image-and-video-processing-al-bovik1.pdf">Konrad</a> - 2000<ul>
<li>introduces acquisition model and several error criteria</li>
<li>focuses on localized motion.  classical methods</li>
</ul>
</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.730.9105&amp;rep=rep1&amp;type=pdf">Sarvaiya, Patnaik, Kothari</a> - 2012<ul>
<li>in-depth treatment to both log-polar transform and phase correlation</li>
<li>introduces methods to account for edge effects during correlation</li>
</ul>
</li>
</ul>
<h3 id="forward-model-and-error-metrics">Forward Model and Error Metrics</h3>
<p>Let <script type="math/tex">I_1</script> and <script type="math/tex">I_2</script> be two images captured at different times of the same scene.  Ignoring edge effects,</p>
<p>
<script type="math/tex; mode=display">
I_1(x) = g(I_2(f(x)))
</script>
<script type="math/tex">g</script> models sensor nonlinearities, so for now we assume it is 1.  <script type="math/tex">f</script> models image transformation.  A common form for <script type="math/tex">f</script> is affine motion: translation, scaling, rotation and shear</p>
<p>
<script type="math/tex; mode=display">
\mathbb{f}(\mathbb{x}) = \left( \begin{matrix}b_1 \\ b_2 \end{matrix} \right) + \left( \begin{matrix}b_3 & b_4 \\ b_5 & b_6\end{matrix} \right) \mathbb{x}
</script>
</p>
<p>However, for remote sensing applications we can simplify <script type="math/tex">f</script> a bit to translation, scaling and rotation - 3 parameters</p>
<p>
<script type="math/tex; mode=display">
\mathbb{f}(\mathbb{x}) = \left( \begin{matrix}b_1 \\ b_2 \end{matrix} \right) + \left( \begin{matrix}\cos \theta & - \sin \theta \\ \sin \theta & \cos \theta\end{matrix} \right) \mathbb{x}
</script>
</p>
<p>The goal of registration is to estimate the parameters of <script type="math/tex">f</script> given <script type="math/tex">I_1</script> and <script type="math/tex">I_2</script>.  To do this, we need to define some notion of cost.  There are several cost criteria given in [Konrad], and some are directly used by some registration methods in finding the parameters of <script type="math/tex">f</script>.  First define</p>
<p>
<script type="math/tex; mode=display">
e(x) = I_2(x) - I_1(\hat{f}(x))
</script>
</p>
<p>Some error metrics are:</p>
<p>
<script type="math/tex; mode=display">
E(\hat{f}) = \sum_x e(x)^2
</script>
</p>
<p>Known as sum of squared errors (SSE), this is the simplest metric and is used by the direct cross-correlation, FFT cross-correlation and gradient descent methods.  However, this metric can potentially give great weight to outliers (e.g. moving objects in foreground or dead CCD pixels).</p>
<p>
<script type="math/tex; mode=display">
E(\hat{f}) = \sum_x \begin{cases}e(x)^2 & |e(x)| < \theta \\ 0 & \text{else}\end{cases}
</script>
</p>
<p>Known as the truncated SSE, it has a threshold to give zero weight to outliers above <script type="math/tex">\theta</script>.</p>
<p>
<script type="math/tex; mode=display">
E(\hat{f}) = \sum_x |e(x)|
</script>
</p>
<p>Absolute error metric.  This metric does not require multiplication and has less computational complex than SSE.  A modified form of this is used in the SSDA method.</p>
<p>With these metrics in hand, we can finally define the objective</p>
<p>
<script type="math/tex; mode=display">
f^* = \arg \min_{\hat{f}} E(\hat{f})
</script>
</p>
<p>Note that the discrete nature of <script type="math/tex">I_1</script> has been ignored up to this point.  In reality, computing <script type="math/tex">I_1(f(x))</script> may require interpolation because <script type="math/tex">f(x)</script> might not fall on the pixel sample grid.  Selection of the interpolation mode is important in certain registration methods.  For example, in the case of gradient descent interpolation must be continuous in the 1st derivative for stability purposes. [Konrad]</p>
<h3 id="correlation-registration-methods">Correlation Registration Methods</h3>
<h5 id="direct-correlation">Direct Correlation</h5>
<p>The most straight forward of all methods, direct correlation only works for small affine transformations where the parameter search space is small. Equivalent to minimizing the SSE metric.  [L. G. Brown]</p>
<p>
<script type="math/tex; mode=display">
f^* = \arg \max_{\hat{f}} \sum_x I_1(x)I_2(\hat{f}(x)) = \arg \min_{\hat{f}} \sum_x e(x)^2
</script>
</p>
<p>Edge effects are again ignored in this formulation.</p>
<h5 id="fft-correlation">FFT Correlation</h5>
<p>Identical to above method (assuming circular correlation), but more computationally feasible.</p>
<h5 id="sequential-similarity-detection-algorithm-ssda">Sequential Similarity Detection Algorithm (SSDA)</h5>
<p>SSDA is an attempt to speed up correlation registration by using the absolute error metric and abandoning cost computations for mismatched <script type="math/tex">\hat{f}</script>'s early.</p>
<p>While SSDA is looping over pixels in <script type="math/tex">I_1</script> and <script type="math/tex">I_2</script> to compute the error <script type="math/tex">E(\hat{f}) = \sum_x |e(x)|</script>, it will periodically check the cumulative sum.  If the sum has passed a certain threshold, the computation stops and the next <script type="math/tex">\hat{f}</script> is evaluted.  Whichever <script type="math/tex">\hat{f}</script> made it furthest into its <script type="math/tex">E(\hat{f})</script> computation (by number of pixels) is deemed the optimum <script type="math/tex">\hat{f}</script>.  [L. G. Brown]</p>
<h5 id="phase-correlation">Phase Correlation</h5>
<p>Phase correlation takes advantage of the fourier-shift property.   When <script type="math/tex">f</script> is a simple translation by <script type="math/tex">u</script> (2D vector), then</p>
<p>
<script type="math/tex; mode=display">
I_2(x) = I_1(x - u) \\
\tilde{I_1}(\omega) = \mathcal{F}(I_1)(\omega) \\
\tilde{I_2}(\omega) = \mathcal{F}(I_2)(\omega) = \tilde{I_1}(\omega)e^{-j \omega u}
</script>
</p>
<p>Computing the normalized cross-spectral power</p>
<p>
<script type="math/tex; mode=display">
R_x(\omega) = \frac{\tilde{I_1}(\omega) \overline{\tilde{I_2}(\omega)}}{|\tilde{I_1}(\omega) \overline{\tilde{I_2}(\omega)}|}
= \frac{\tilde{I_1}(\omega) \overline{\tilde{I_1}(\omega)}e^{j \omega u}}{|\tilde{I_1}(\omega) \overline{\tilde{I_1}(\omega)}e^{j \omega u}|} = e^{j \omega u}
</script>
</p>
<p>And so <script type="math/tex">u</script> can be found by the maximization</p>
<p>
<script type="math/tex; mode=display">
u^* = \arg \max_{\hat{u}} \mathcal{F}^{-1}(R_x(\omega)) = \arg \max_{\hat{u}} \delta(\hat{u} - u)
</script>
</p>
<!-- ### Optimizer Registration Methods -->

<h3 id="handling-scale-and-rotation">Handling Scale and Rotation</h3>
<h5 id="log-polar-fourier-mellin-transform">Log-Polar (Fourier-Mellin) transform</h5>
<p><figure alt="Two nanoflare sources and their log-polar transforms"><img src="quad.png" /><figcaption>Two nanoflare sources and their log-polar transforms</figcaption></figure></p>
<p><figure alt="Two noisy nanoflare sources (10 counts) and their log-polar transforms.  Scale and rotation errors were 1.5 and 5%"><img src="quad_noise.png" /><figcaption>Two noisy nanoflare sources (10 counts) and their log-polar transforms.  Scale and rotation errors were 1.5 and 5%</figcaption></figure></p>
<h3 id="other-methods-not-investigated">Other methods not investigated</h3>
<ul>
<li>
<p>Lukas-Kanade - a pixel-based optical flow algorithm</p>
</li>
<li>
<p>Levenberg-Marquardt - damped gradient method on sum of squared errors</p>
</li>
<li>
<p>RANSAC - feature/landmark detection method</p>
<!-- * SSDA (Barnea and Silverman 1972) -->

</li>
</ul>
<h3 id="other-papers">Other Papers</h3>
<ul>
<li><a href="https://journals.sagepub.com/doi/full/10.1177/0954410017691315">Observation satellite attitude estimation using sensor measurement and image registration fusion</a><ul>
<li>improved optical flow method (Lukas-Kanade algorithm)</li>
<li>specifically addresses application to satellite estimation</li>
<li>includes Kalman filter formulation for fusion of star-tracker, gyro, and image registration attitude estimates</li>
</ul>
</li>
<li>[Wolberg, Zokai] - </li>
</ul>
<h3 id="research-ideas">Research Ideas</h3>
<ul>
<li>use NUDFT instead of interpolating after log-polar transform<ul>
<li>The phase-correlation + log-polar method relies on interpolation to resample the transformed image onto a rectangular grid before correlating the result.  This necessarily means choosing a potentially suboptimal interpolation scheme.  Maybe this can be avoided by using NUDFT to perform the phase-correlation step.</li>
</ul>
</li>
<li>apply Prony's method to phase correlation<ul>
<li>From my previous research on subpixel methods, it seems most papers take an iterative or hierarchal approach to subpixel registration.  I've looked specifically for papers which utilize prony's method to recover the peak in phase correlation, but haven't found any.</li>
</ul>
</li>
</ul>
<p><figure alt="Residual numerical error after log-polar transform" style="height:100%"><img src="error.png" /><figcaption>Residual numerical error after log-polar transform</figcaption></figure></p>
  </article>
</main>
<footer>
    <p>SINE UIUC</p>
</footer>
</body>
</html>